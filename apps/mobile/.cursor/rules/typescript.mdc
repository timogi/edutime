---
alwaysApply: true
description: "Always use TypeScript best practices. Define proper interfaces, use strict typing, avoid 'any' types, and maintain type safety throughout the codebase."
---

# TypeScript Rules for EduTime Native

## üö´ Never Do This
```typescript
// ‚ùå Using 'any' type
const data: any = fetchData();
const handlePress = (event: any) => {};

// ‚ùå Missing type definitions
function processUser(user) {
  return user.name;
}

// ‚ùå Loose typing
const styles = {
  container: { flex: 1 }
};

// ‚ùå Untyped props
interface ComponentProps {
  onPress: () => void;
  data: any; // ‚ùå Too loose
}
```

## ‚úÖ Always Do This
```typescript
// ‚úÖ Proper type definitions
interface User {
  id: string;
  name: string;
  email: string;
}

const data: User[] = fetchData();

// ‚úÖ Typed event handlers
const handlePress = (event: GestureResponderEvent) => {};

// ‚úÖ Typed styles
const styles = StyleSheet.create({
  container: {
    flex: 1,
  }
});

// ‚úÖ Specific prop types
interface ComponentProps {
  onPress: () => void;
  data: User | null;
  isLoading?: boolean;
}
```

## üìÅ Files to Always Touch for TypeScript

### 1. **Type Definition Files**
- `lib/types.ts` - Custom type definitions
- `database.types.ts` - Generated Supabase types
- `components/**/*.tsx` - Component prop interfaces
- `hooks/**/*.ts` - Hook return types

### 2. **Component Files** (When adding new features)
- `app/**/*.tsx` - Screen prop types
- `components/**/*.tsx` - Component interfaces
- `contexts/**/*.tsx` - Context type definitions

## üèóÔ∏è TypeScript Patterns

### 1. **Database Types First**
```typescript
// ‚úÖ ALWAYS use database types when available
import { Database } from '@/database.types';

// Use generated Supabase types
type TimeRecord = Database['public']['Tables']['records']['Row'];
type CreateTimeRecord = Database['public']['Tables']['records']['Insert'];
type UpdateTimeRecord = Database['public']['Tables']['records']['Update'];

// ‚úÖ Only create custom types when database types don't exist
interface CustomComponentProps {
  onPress: () => void;
  isLoading?: boolean;
}

// ‚úÖ Use type aliases for unions and primitives
type Theme = 'light' | 'dark';
type ButtonVariant = 'solid' | 'outline' | 'link';
```

### 2. **Component Props with Database Types**
```typescript
// ‚úÖ Use database types in component props
import { Database } from '@/database.types';

type TimeRecord = Database['public']['Tables']['records']['Row'];
type CreateTimeRecord = Database['public']['Tables']['records']['Insert'];

interface RecordFormProps {
  record?: TimeRecord; // Use database Row type
  onSave: (record: CreateTimeRecord) => void; // Use database Insert type
  onCancel: () => void;
  isLoading?: boolean;
}

export const RecordForm: React.FC<RecordFormProps> = ({
  record,
  onSave,
  onCancel,
  isLoading = false
}) => {
  // Component implementation
};
```

### 3. **Hook Return Types with Database Types**
```typescript
// ‚úÖ Use database types in hook returns
import { Database } from '@/database.types';

type User = Database['public']['Tables']['users']['Row'];

interface UseUserReturn {
  user: User | null; // Use database Row type
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
}

export const useUser = (): UseUserReturn => {
  // Hook implementation
};
```

### 4. **API Response Types with Database Types**
```typescript
// ‚úÖ Use database types in API responses
import { Database } from '@/database.types';

type TimeRecord = Database['public']['Tables']['records']['Row'];

interface ApiResponse<T> {
  data: T;
  error: string | null;
  loading: boolean;
}

interface RecordsResponse {
  records: TimeRecord[]; // Use database Row type
  total: number;
  hasMore: boolean;
}
```

## üéØ Common TypeScript Patterns

### 1. **Generic Types**
```typescript
// ‚úÖ Use generics for reusable types
interface ApiHook<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

// Usage
const { data: records, loading } = useApi<TimeRecord[]>('/records');
```

### 2. **Utility Types with Database Types**
```typescript
// ‚úÖ Use utility types with database types
import { Database } from '@/database.types';

type TimeRecord = Database['public']['Tables']['records']['Row'];
type CreateTimeRecord = Database['public']['Tables']['records']['Insert'];
type UpdateTimeRecord = Database['public']['Tables']['records']['Update'];

// ‚úÖ Use database Insert/Update types instead of utility types
type CreateRecord = CreateTimeRecord; // Use database Insert type
type UpdateRecord = UpdateTimeRecord; // Use database Update type

// ‚úÖ Only use utility types for custom transformations
type RecordFormData = Pick<TimeRecord, 'date' | 'duration' | 'description'>;
```

### 3. **Enum Alternatives**
```typescript
// ‚úÖ Use const assertions instead of enums
const THEME = {
  LIGHT: 'light',
  DARK: 'dark'
} as const;

type Theme = typeof THEME[keyof typeof THEME];
```

## üîß Implementation Guidelines

### 1. **Strict Type Checking**
```typescript
// ‚úÖ Enable strict mode in tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

### 2. **Type Guards**
```typescript
// ‚úÖ Use type guards for runtime type checking
function isTimeRecord(obj: any): obj is TimeRecord {
  return obj && 
    typeof obj.id === 'number' &&
    typeof obj.date === 'string' &&
    typeof obj.duration === 'number';
}
```

### 3. **Error Handling Types**
```typescript
// ‚úÖ Type error states
interface ErrorState {
  message: string;
  code?: string;
  field?: string;
}

type Result<T> = 
  | { success: true; data: T }
  | { success: false; error: ErrorState };
```

## ‚ö†Ô∏è Critical Rules

1. **Database types first** - Always use `Database['public']['Tables']['table']['Row']` when available
2. **Never use 'any'** - Use proper types or 'unknown'
3. **Use database Insert/Update types** - Don't create custom types for CRUD operations
4. **Define custom interfaces only when needed** - For component props, UI state, etc.
5. **Use strict mode** - Enable all strict TypeScript options
6. **Type all props** - Every component should have typed props
7. **Type all hooks** - Define return types for custom hooks
8. **Use generics** - For reusable type patterns

## üîç Files That Need TypeScript Attention

Based on your codebase, these files commonly need type improvements:
- `components/RecordForm/RecordForm.tsx` - Form prop types
- `components/RecordList.tsx` - List item types
- `hooks/useRecordsQuery.ts` - Hook return types
- `contexts/UserContext.tsx` - Context type definitions
- `lib/database/*.ts` - Database function types

## üöÄ Quick Checklist

When adding new code:
- [ ] **Check database types first** - Use `Database['public']['Tables']['table']['Row']` when available
- [ ] **Use database Insert/Update types** - For CRUD operations
- [ ] **Define custom interfaces only when needed** - For component props, UI state
- [ ] Type all component props
- [ ] Type all function parameters and returns
- [ ] Use generics for reusable patterns
- [ ] Avoid 'any' type
- [ ] Use utility types for custom transformations only
- [ ] Add type guards for runtime checks
- [ ] Enable strict TypeScript options

## üìä TypeScript Quality Score

**Current Status: 8/10**
- ‚úÖ Good use of interfaces in most places
- ‚úÖ Proper component prop typing
- ‚úÖ Good database type integration
- ‚ö†Ô∏è Some 'any' types that could be improved
- ‚ö†Ô∏è Missing some hook return types
- ‚ö†Ô∏è Could benefit from more utility types