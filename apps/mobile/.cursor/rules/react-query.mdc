---
alwaysApply: true
description: "Always use React Query for server state management. Use proper query keys, handle loading/error states, implement optimistic updates, and follow established data fetching patterns."
---

# React Query Rules for EduTime Native

## üö´ Never Do This
```typescript
// ‚ùå Direct API calls in components
const [data, setData] = useState(null);
const [loading, setLoading] = useState(false);

useEffect(() => {
  setLoading(true);
  fetchRecords().then(setData).finally(() => setLoading(false));
}, []);

// ‚ùå Inconsistent query keys
useQuery(['records'], fetchRecords);
useQuery(['time-records'], fetchRecords); // Different key for same data

// ‚ùå No error handling
const { data } = useQuery(['records'], fetchRecords);
// No loading or error states handled
```

## ‚úÖ Always Do This
```typescript
// ‚úÖ Use React Query hooks
const { data, isLoading, error, refetch } = useQuery({
  queryKey: ['records'],
  queryFn: fetchRecords,
  staleTime: 5 * 60 * 1000, // 5 minutes
});

// ‚úÖ Consistent query keys
const RECORD_QUERY_KEYS = {
  all: ['records'] as const,
  lists: () => [...RECORD_QUERY_KEYS.all, 'list'] as const,
  list: (filters: RecordFilters) => [...RECORD_QUERY_KEYS.lists(), filters] as const,
  details: () => [...RECORD_QUERY_KEYS.all, 'detail'] as const,
  detail: (id: number) => [...RECORD_QUERY_KEYS.details(), id] as const,
};

// ‚úÖ Proper error and loading handling
const { data, isLoading, error } = useQuery({
  queryKey: RECORD_QUERY_KEYS.lists(),
  queryFn: fetchRecords,
});

if (isLoading) return <LoadingSpinner />;
if (error) return <ErrorMessage error={error} />;
```

## üìÅ Files to Always Touch for React Query

### 1. **Query Hook Files**
- `hooks/useRecordsQuery.ts` - Records data fetching
- `hooks/useStopWatchQuery.ts` - Stopwatch data
- `hooks/useDailyDurationsQuery.ts` - Daily data
- `lib/react-query.tsx` - Query client configuration

### 2. **Component Files** (When using server data)
- `components/RecordList.tsx` - Record display
- `components/RecordForm/RecordForm.tsx` - Form data
- `app/(app)/index.tsx` - Main screen data

## üèóÔ∏è React Query Patterns

### 1. **Query Key Factory**
```typescript
// ‚úÖ Create query key factories
export const recordKeys = {
  all: ['records'] as const,
  lists: () => [...recordKeys.all, 'list'] as const,
  list: (filters: RecordFilters) => [...recordKeys.lists(), filters] as const,
  details: () => [...recordKeys.all, 'detail'] as const,
  detail: (id: number) => [...recordKeys.details(), id] as const,
} as const;
```

### 2. **Custom Query Hooks**
```typescript
// ‚úÖ Create custom hooks for queries
export const useRecords = (filters?: RecordFilters) => {
  return useQuery({
    queryKey: recordKeys.list(filters || {}),
    queryFn: () => fetchRecords(filters),
    staleTime: 5 * 60 * 1000,
  });
};

export const useRecord = (id: number) => {
  return useQuery({
    queryKey: recordKeys.detail(id),
    queryFn: () => fetchRecord(id),
    enabled: !!id,
  });
};
```

### 3. **Mutation Patterns**
```typescript
// ‚úÖ Use mutations for data changes
export const useCreateRecord = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: createRecord,
    onSuccess: (newRecord) => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: recordKeys.lists() });
      
      // Optimistic update
      queryClient.setQueryData(
        recordKeys.detail(newRecord.id),
        newRecord
      );
    },
    onError: (error) => {
      // Handle error
      console.error('Failed to create record:', error);
    },
  });
};
```

### 4. **Optimistic Updates**
```typescript
// ‚úÖ Implement optimistic updates
const updateRecordMutation = useMutation({
  mutationFn: updateRecord,
  onMutate: async (newRecord) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries({ queryKey: recordKeys.detail(newRecord.id) });
    
    // Snapshot previous value
    const previousRecord = queryClient.getQueryData(recordKeys.detail(newRecord.id));
    
    // Optimistically update
    queryClient.setQueryData(recordKeys.detail(newRecord.id), newRecord);
    
    return { previousRecord };
  },
  onError: (err, newRecord, context) => {
    // Rollback on error
    queryClient.setQueryData(recordKeys.detail(newRecord.id), context?.previousRecord);
  },
  onSettled: (data, error, variables) => {
    // Always refetch after error or success
    queryClient.invalidateQueries({ queryKey: recordKeys.detail(variables.id) });
  },
});
```

## üéØ Common React Query Patterns

### 1. **Loading States**
```typescript
// ‚úÖ Handle loading states properly
const { data, isLoading, isFetching, isPending } = useRecords();

// Use isPending for initial load, isFetching for background updates
if (isPending) return <LoadingSpinner />;
if (isFetching) return <LoadingSpinner overlay />;
```

### 2. **Error Handling**
```typescript
// ‚úÖ Comprehensive error handling
const { data, error, isError } = useRecords();

if (isError) {
  return (
    <ErrorMessage 
      error={error} 
      onRetry={() => refetch()} 
    />
  );
}
```

### 3. **Cache Management**
```typescript
// ‚úÖ Proper cache invalidation
const deleteRecordMutation = useMutation({
  mutationFn: deleteRecord,
  onSuccess: (_, deletedId) => {
    // Remove from cache
    queryClient.removeQueries({ queryKey: recordKeys.detail(deletedId) });
    
    // Invalidate lists
    queryClient.invalidateQueries({ queryKey: recordKeys.lists() });
  },
});
```

### 4. **Background Refetching**
```typescript
// ‚úÖ Configure background refetching
const { data } = useQuery({
  queryKey: recordKeys.lists(),
  queryFn: fetchRecords,
  staleTime: 5 * 60 * 1000, // 5 minutes
  refetchOnWindowFocus: true,
  refetchOnMount: true,
});
```

## üîß Implementation Guidelines

### 1. **Query Configuration**
```typescript
// ‚úÖ Standard query configuration
const defaultQueryOptions = {
  staleTime: 5 * 60 * 1000, // 5 minutes
  cacheTime: 10 * 60 * 1000, // 10 minutes
  refetchOnWindowFocus: false,
  retry: 3,
  retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
};
```

### 2. **Error Boundaries**
```typescript
// ‚úÖ Use error boundaries for query errors
<QueryErrorResetBoundary>
  {({ reset }) => (
    <ErrorBoundary
      onReset={reset}
      fallbackRender={({ error, resetErrorBoundary }) => (
        <ErrorMessage 
          error={error} 
          onRetry={resetErrorBoundary} 
        />
      )}
    >
      <RecordsList />
    </ErrorBoundary>
  )}
</QueryErrorResetBoundary>
```

### 3. **Suspense Integration**
```typescript
// ‚úÖ Use Suspense for loading states
<Suspense fallback={<LoadingSpinner />}>
  <RecordsList />
</Suspense>
```

## ‚ö†Ô∏è Critical Rules

1. **Use query keys consistently** - Follow the established key factory pattern
2. **Handle all states** - Loading, error, and success states
3. **Implement optimistic updates** - For better UX
4. **Invalidate cache properly** - Keep data fresh
5. **Use custom hooks** - Encapsulate query logic
6. **Configure stale time** - Balance performance and freshness

## üîç Files That Need React Query Attention

Based on your codebase, these files commonly need query improvements:
- `hooks/useRecordsQuery.ts` - Record fetching patterns
- `components/RecordList.tsx` - List data handling
- `components/RecordForm/RecordForm.tsx` - Form mutations
- `contexts/UserContext.tsx` - User data fetching
- `app/(app)/index.tsx` - Main screen queries

## üöÄ Quick Checklist

When using React Query:
- [ ] Use consistent query keys
- [ ] Handle loading, error, and success states
- [ ] Implement optimistic updates for mutations
- [ ] Use custom hooks for queries
- [ ] Configure proper stale time
- [ ] Invalidate cache after mutations
- [ ] Use error boundaries for error handling
- [ ] Test query behavior

## üìä React Query Quality Score

**Current Status: 8/10**
- ‚úÖ Good use of React Query throughout
- ‚úÖ Proper mutation patterns
- ‚úÖ Good error handling in most places
- ‚ö†Ô∏è Some inconsistent query keys
- ‚ö†Ô∏è Could benefit from more optimistic updates
- ‚ö†Ô∏è Missing some custom query hooks