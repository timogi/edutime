---
alwaysApply: true
description: "Always implement proper error handling. Use try-catch blocks, display user-friendly error messages, implement error boundaries, and log errors appropriately. Use custom toast component for notifications."
---

# Error Handling Rules for EduTime Native

## üö´ Never Do This
```typescript
// ‚ùå Silent failures
const handlePress = async () => {
  await saveRecord(); // No error handling
};

// ‚ùå Generic error messages
catch (error) {
  alert('Something went wrong');
}

// ‚ùå No error boundaries
<ComponentThatMightCrash />
// No error boundary protection

// ‚ùå Hardcoded error messages
<Text>Error: {error.message}</Text>
```

## ‚úÖ Always Do This
```typescript
// ‚úÖ Proper error handling
const handlePress = async () => {
  try {
    await saveRecord();
    showToast('Record saved successfully', 'success');
  } catch (error) {
    console.error('Failed to save record:', error);
    showToast('Failed to save record. Please try again.', 'error');
  }
};

// ‚úÖ User-friendly error messages
catch (error) {
  const message = getErrorMessage(error);
  showToast(message, 'error');
}

// ‚úÖ Error boundaries
<ErrorBoundary fallback={<ErrorFallback />}>
  <ComponentThatMightCrash />
</ErrorBoundary>

// ‚úÖ Internationalized error messages
<Text>{t('Errors.save-failed')}</Text>
```

## üìÅ Files to Always Touch for Error Handling

### 1. **Error Handling Files**
- `components/ui/Toast.tsx` - Custom toast component
- `components/ErrorBoundary.tsx` - Error boundary component
- `lib/error-handling.ts` - Error handling utilities
- `lib/i18n/locales/*.json` - Error message translations

### 2. **Component Files** (When adding error handling)
- `components/**/*.tsx` - All components need error handling
- `app/**/*.tsx` - All screens need error boundaries
- `hooks/**/*.ts` - All hooks need error handling

## üèóÔ∏è Error Handling Patterns

### 1. **Custom Toast Component**
```typescript
// ‚úÖ Create custom toast component (since Gluestack toast doesn't always work)
import Toast from 'react-native-toast-message';

interface ToastProps {
  type: 'success' | 'error' | 'info' | 'warning';
  title: string;
  message?: string;
  duration?: number;
}

export const showToast = ({ type, title, message, duration = 3000 }: ToastProps) => {
  Toast.show({
    type,
    text1: title,
    text2: message,
    visibilityTime: duration,
    position: 'bottom',
  });
};

// Usage
showToast({
  type: 'success',
  title: 'Success',
  message: 'Record saved successfully'
});
```

### 2. **Error Boundary Component**
```typescript
// ‚úÖ Create error boundary component
interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends React.Component<
  { children: React.ReactNode; fallback?: React.ComponentType<{ error: Error }> },
  ErrorBoundaryState
> {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // Log to crash reporting service
  }

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return <FallbackComponent error={this.state.error!} />;
    }

    return this.props.children;
  }
}
```

### 3. **Error Message Utilities**
```typescript
// ‚úÖ Create error message utilities
export const getErrorMessage = (error: unknown): string => {
  if (error instanceof Error) {
    return error.message;
  }
  
  if (typeof error === 'string') {
    return error;
  }
  
  return 'An unexpected error occurred';
};

export const getErrorCode = (error: unknown): string | null => {
  if (error && typeof error === 'object' && 'code' in error) {
    return String(error.code);
  }
  return null;
};
```

### 4. **Async Error Handling**
```typescript
// ‚úÖ Proper async error handling
const handleAsyncOperation = async () => {
  try {
    setLoading(true);
    const result = await apiCall();
    showToast({ type: 'success', title: 'Success' });
    return result;
  } catch (error) {
    const message = getErrorMessage(error);
    showToast({ type: 'error', title: 'Error', message });
    throw error; // Re-throw if needed
  } finally {
    setLoading(false);
  }
};
```

## üéØ Common Error Handling Patterns

### 1. **Form Validation Errors**
```typescript
// ‚úÖ Handle form validation errors
const handleSubmit = async (data: FormData) => {
  try {
    await submitForm(data);
    showToast({ type: 'success', title: 'Form submitted' });
  } catch (error) {
    if (error.code === 'VALIDATION_ERROR') {
      // Handle validation errors
      setFieldErrors(error.details);
    } else {
      showToast({ type: 'error', title: 'Submission failed' });
    }
  }
};
```

### 2. **Network Error Handling**
```typescript
// ‚úÖ Handle network errors
const handleNetworkError = (error: unknown) => {
  if (error.code === 'NETWORK_ERROR') {
    showToast({
      type: 'error',
      title: 'Network Error',
      message: 'Please check your internet connection'
    });
  } else {
    showToast({
      type: 'error',
      title: 'Error',
      message: 'Something went wrong'
    });
  }
};
```

### 3. **Mutation Error Handling**
```typescript
// ‚úÖ Handle mutation errors
const deleteRecordMutation = useMutation({
  mutationFn: deleteRecord,
  onError: (error) => {
    const message = getErrorMessage(error);
    showToast({
      type: 'error',
      title: 'Delete Failed',
      message
    });
  },
  onSuccess: () => {
    showToast({
      type: 'success',
      title: 'Record Deleted'
    });
  }
});
```

### 4. **Error Recovery**
```typescript
// ‚úÖ Implement error recovery
const ErrorFallback = ({ error, resetError }: { error: Error; resetError: () => void }) => {
  return (
    <View style={styles.errorContainer}>
      <Text style={styles.errorTitle}>Something went wrong</Text>
      <Text style={styles.errorMessage}>{error.message}</Text>
      <Button onPress={resetError} title="Try Again" />
    </View>
  );
};
```

## üîß Implementation Guidelines

### 1. **Error Logging**
```typescript
// ‚úÖ Log errors appropriately
const logError = (error: Error, context?: string) => {
  console.error(`[${context || 'Unknown'}] Error:`, error);
  
  // Log to crash reporting service
  if (__DEV__) {
    console.error('Stack trace:', error.stack);
  }
};
```

### 2. **Error Recovery Strategies**
```typescript
// ‚úÖ Implement retry logic
const retryableOperation = async (operation: () => Promise<any>, maxRetries = 3) => {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
};
```

### 3. **Error Boundary Usage**
```typescript
// ‚úÖ Use error boundaries strategically
<ErrorBoundary fallback={ErrorFallback}>
  <MainApp />
</ErrorBoundary>

// For specific components
<ErrorBoundary fallback={FormErrorFallback}>
  <RecordForm />
</ErrorBoundary>
```

## ‚ö†Ô∏è Critical Rules

1. **Always handle errors** - Never let errors go unhandled
2. **Use custom toast** - Since Gluestack toast doesn't always work
3. **Provide user-friendly messages** - Don't show technical errors to users
4. **Log errors appropriately** - For debugging and monitoring
5. **Implement error boundaries** - Prevent app crashes
6. **Use internationalized messages** - Support multiple languages

## üîç Files That Need Error Handling Attention

Based on your codebase, these files commonly need error handling:
- `components/RecordForm/RecordForm.tsx` - Form submission errors
- `components/RecordList.tsx` - Data loading errors
- `app/(app)/index.tsx` - Main screen errors
- `contexts/UserContext.tsx` - Authentication errors
- `hooks/useRecordsQuery.ts` - Query errors

## üöÄ Quick Checklist

When adding error handling:
- [ ] Wrap async operations in try-catch
- [ ] Use custom toast component for notifications
- [ ] Implement error boundaries for components
- [ ] Provide user-friendly error messages
- [ ] Log errors for debugging
- [ ] Use internationalized error messages
- [ ] Implement retry logic where appropriate
- [ ] Test error scenarios

## üìä Error Handling Quality Score

**Current Status: 6/10**
- ‚úÖ Some error handling in place
- ‚úÖ Good use of try-catch blocks
- ‚ö†Ô∏è Missing custom toast component
- ‚ö†Ô∏è Inconsistent error messages
- ‚ö†Ô∏è Missing error boundaries in some places
- ‚ö†Ô∏è Could benefit from better error recovery