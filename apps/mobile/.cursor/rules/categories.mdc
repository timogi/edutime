# Category Rules for EduTime Native

## üö´ Never Do This
```typescript
// ‚ùå Hardcoding category types
if (categoryId === 1) { /* handle category 1 */ }
if (categoryId === 2) { /* handle category 2 */ }

// ‚ùå Mixing category logic
const isUserCategory = record.category_id === userCategoryId; // Wrong!

// ‚ùå Not checking canton context
const getCategoryColor = (record) => {
  return record.color; // Missing canton validation
};

// ‚ùå Inconsistent category filtering
const userCategories = categories.filter(cat => cat.is_user_category); // Wrong field!
```

## ‚úÖ Always Do This
```typescript
// ‚úÖ Use proper category type checking
if (record.is_user_category && record.user_category_id) {
  // Handle user categories
} else if (record.category_id) {
  // Handle regular categories
} else {
  // Handle no category
}

// ‚úÖ Check canton context for category validation
const isValidCategory = (record, currentCantonCategories) => {
  if (record.is_user_category) return true; // User categories are always valid
  return currentCantonCategories.some(cat => cat.id === record.category_id);
};

// ‚úÖ Use proper category filtering
const userCategories = categories.filter(cat => cat.is_further_employment);
```

## üìÅ Files to Always Touch for Category Handling

### 1. **Core Category Files**
- `lib/database/categories.ts` - Category data fetching and management
- `lib/database/canton.ts` - Canton-specific category sets
- `contexts/UserContext.tsx` - User category context and state
- `lib/database/records.ts` - Record-category relationships

### 2. **Component Files** (When handling categories)
- `components/statistics/CategoryStatsTable.tsx` - Category display and navigation
- `app/category-details.tsx` - Category-specific record views
- `app/(app)/statistics.tsx` - Statistics with category grouping

## üèóÔ∏è Category Type System

### 1. **Category Classification**
```typescript
// ‚úÖ Three main category types
interface CategoryType {
  // Regular Canton Categories
  regular: {
    category_id: number;
    is_user_category: false;
    category_set_title: string; // e.g., 'teaching', 'administration'
  };
  
  // User Categories (Weiterbesch√§ftigung)
  user: {
    user_category_id: number;
    is_user_category: true;
    category_set_title: 'furtherEmployment';
  };
  
  // No Category
  none: {
    category_id: null;
    user_category_id: null;
    is_user_category: false;
  };
}
```

### 2. **Category Set Titles**
```typescript
// ‚úÖ Standard category set titles
const CATEGORY_SET_TITLES = {
  FURTHER_EMPLOYMENT: 'furtherEmployment', // User categories
  TEACHING: 'teaching',                    // Regular teaching categories
  ADMINISTRATION: 'administration',       // Regular admin categories
  // ... other canton-specific sets
} as const;
```

### 3. **Category Detection Logic**
```typescript
// ‚úÖ Proper category type detection
const getCategoryType = (record: TimeRecord) => {
  if (record.is_user_category && record.user_category_id) {
    return 'user'; // User category (Weiterbesch√§ftigung)
  } else if (record.category_id) {
    return 'regular'; // Regular canton category
  } else {
    return 'none'; // No category assigned
  }
};

// ‚úÖ Canton context validation
const isCurrentCantonCategory = (record: TimeRecord, currentCantonCategories: CategoryResult[]) => {
  if (record.is_user_category) return true; // User categories are always valid
  return currentCantonCategories.some(cat => cat.id === record.category_id);
};
```

## üéØ Category Handling Patterns

### 1. **User Categories (Weiterbesch√§ftigung)**
```typescript
// ‚úÖ User categories are identified by:
// - is_user_category: true
// - user_category_id: number
// - category_set_title: 'furtherEmployment'

const getUserCategories = (categories: CategoryResult[]) => {
  return categories.filter(cat => cat.is_further_employment);
};

// ‚úÖ User category records
const getUserCategoryRecords = (records: TimeRecord[]) => {
  return records.filter(record => 
    record.is_user_category && record.user_category_id
  );
};
```

### 2. **No Category Records**
```typescript
// ‚úÖ No category means:
// - category_id: null
// - user_category_id: null
// - is_user_category: false

const getNoCategoryRecords = (records: TimeRecord[]) => {
  return records.filter(record => 
    !record.category_id && !record.user_category_id && !record.is_user_category
  );
};
```

### 3. **Other Canton Records**
```typescript
// ‚úÖ Other canton means:
// - category_id exists but doesn't match current canton categories
// - is_user_category: false
// - category_id not in currentCantonCategoryIds

const getOtherCantonRecords = (records: TimeRecord[], currentCantonCategoryIds: number[]) => {
  return records.filter(record => 
    record.category_id && 
    !currentCantonCategoryIds.includes(record.category_id) &&
    !record.is_user_category
  );
};
```

## üîß Implementation Guidelines

### 1. **Category Statistics Handling**
```typescript
// ‚úÖ Handle different category types in statistics
const handleCategoryPress = (categoryId: number | null, isUserCategory: boolean, categoryTitle: string) => {
  if (categoryTitle.includes('Weitere Anstellungen') || categoryTitle.includes('Further employments')) {
    // User categories - get all user categories for this user
    return getUserCategoryRecords(startDate, endDate, userId);
  } else if (categoryTitle.includes('Keine Kategorie') || categoryTitle.includes('No category')) {
    // No category records
    return getNoCategoryRecords(startDate, endDate, userId);
  } else if (categoryTitle.includes('Anderer Kanton') || categoryTitle.includes('Other canton')) {
    // Other canton records
    return getOtherCantonRecords(startDate, endDate, userId, currentCantonCategoryIds);
  } else {
    // Regular category
    return getRecordsByCategory(startDate, endDate, userId, categoryId, isUserCategory);
  }
};
```

### 2. **Category Color Assignment**
```typescript
// ‚úÖ Get category color with proper fallbacks
const getCategoryColor = (record: TimeRecord, categories: CategoryResult[]) => {
  if (record.is_user_category && record.user_category_id) {
    const userCategory = categories.find(cat => 
      cat.id === record.user_category_id && cat.is_further_employment
    );
    return userCategory?.color || theme.primary[5];
  } else if (record.category_id) {
    const category = categories.find(cat => 
      cat.id === record.category_id && !cat.is_further_employment
    );
    return category?.color || theme.primary[5];
  }
  return theme.primary[5]; // Default color
};
```

### 3. **Category Navigation**
```typescript
// ‚úÖ Navigate to category details with proper parameters
const navigateToCategoryDetails = (categoryId: number | null, isUserCategory: boolean, categoryTitle: string) => {
  router.push({
    pathname: '/category-details',
    params: {
      categoryId: categoryId?.toString() || '',
      isUserCategory: isUserCategory.toString(),
      categoryTitle,
      startDate: startDate.toISOString(),
      endDate: endDate.toISOString(),
      userId: user.user_id,
    }
  });
};
```

## ‚ö†Ô∏è Critical Rules

1. **Always check `is_user_category` first** - User categories have different logic
2. **Validate canton context** - Categories must belong to current canton
3. **Handle null values properly** - No category means both IDs are null
4. **Use proper category set titles** - 'furtherEmployment' for user categories
5. **Check category existence** - Always validate category exists before using
6. **Handle edge cases** - Other canton, no category, invalid categories

## üîç Category Type Detection

### **User Categories (Weiterbesch√§ftigung):**
- `is_user_category: true`
- `user_category_id: number`
- `category_set_title: 'furtherEmployment'`
- **Title**: "Weitere Anstellungen" (DE), "Further employments" (EN), "Autres emplois" (FR)
- **Query Logic**: Get all user category IDs from categories array, then fetch records with `is_user_category = true` AND `user_category_id IN (userCategoryIds)`
- **Subcategory Display**: Use `record.user_categories?.subtitle` with `t('Categories.subcategory')` translation

### **Canton Categories (Regular Categories):**
- `is_user_category: false`
- `category_id: number`
- **Subcategory Display**: Use `record.categories?.subtitle` with `t('Categories.subcategory')` translation

### **No Category:**
- `category_id: null`
- `user_category_id: null`
- `is_user_category: false`
- **Title**: "Keine Kategorie" (DE), "No category" (EN), "Pas de cat√©gorie" (FR)

### **Other Canton:**
- `category_id: number` (but not in current canton)
- `is_user_category: false`
- **Title**: "Anderer Kanton" (DE), "Other canton" (EN), "Autre canton" (FR)

### **Regular Categories:**
- `category_id: number`
- `is_user_category: false`
- `category_set_title: string` (canton-specific)

## üöÄ Quick Checklist

When handling categories:
- [ ] Check `is_user_category` first
- [ ] Validate canton context for regular categories
- [ ] Handle null values for no category
- [ ] Use proper category set titles
- [ ] Check category existence before using
- [ ] Handle edge cases (other canton, invalid categories)
- [ ] Use proper filtering methods
- [ ] Test all category types

## üìä Category Quality Score

**Current Status: 9/10**
- ‚úÖ Proper category type detection
- ‚úÖ Good canton context validation
- ‚úÖ Correct user category handling
- ‚úÖ Proper no category detection
- ‚úÖ Good other canton handling
- ‚ö†Ô∏è Could benefit from more type safety
- ‚ö†Ô∏è Missing some edge case handling